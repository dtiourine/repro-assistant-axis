import json
from pathlib import Path
from typing import Dict, List
import pandas as pd
from tqdm import tqdm
from pprint import pprint 
from repro_assistant_axis.config import DATA_DIR


def load_roles():
    with open(DATA_DIR / "roles.json", "r", encoding="utf-8") as f:
        roles_json = json.load(f) 
        
    roles = roles_json["roles"]
    assert len(roles) == 275, f"Expected 275 roles, got {len(roles)}"
    pprint(roles)
    return roles 


def load_extraction_questions():
    with open(DATA_DIR / "extraction_questions.json", "r", encoding="utf-8") as f:
        extraction_questions_json = json.load(f)
    
    extraction_questions = extraction_questions_json["questions"]
    assert len(extraction_questions) == 240, f"Expected 240 extraction questions, got {len(extraction_questions)}"
       
    return extraction_questions

def clean_roles():
    with open(DATA_DIR / "roles.json", "r", encoding="utf-8") as f:
        roles_json = json.load(f) 
        
    print(f"Original roles: {len(roles_json)}")
    seen_roles = set()
    cleaned_roles = []
    
    for role_item in roles_json:
        role = role_item["role"]
        
        if role not in seen_roles:
            seen_roles.add(role)
            cleaned_roles.append(role)
        else:
            print(f"Duplicate removed: {role}")
            
    print(f"After removing duplicates: {len(cleaned_roles)}")
    
    if len(cleaned_roles) > 275:
        print(f"Need to remove {len(cleaned_roles) - 275} more roles")
    
    # Option 1: Keep first 275 alphabetically
        import random 
        random.seed(42)
        
        random.shuffle(cleaned_roles)
        cleaned_roles = cleaned_roles[:275]
    
    # Option 2: Manually select which to remove
    # roles_to_remove = ['role1', 'role2', ...]
    # for role in roles_to_remove:
    #     cleaned_roles.pop(role, None)

    print(f"Final roles: {len(cleaned_roles)}")

    cleaned_roles_json = {
        "description": "275 unique roles designed for the model",
        "source": "Generated by Claude Sonnet 4.5",
        "count": len(cleaned_roles),
        "roles": cleaned_roles
    }

    # Save cleaned roles
    with open(DATA_DIR / "roles_cleaned.json", "w") as f:
        json.dump(cleaned_roles_json, f, indent=2)
    
    
def generate_rollouts():
    extraction_questions = load_extraction_questions()
    
import json
from pathlib import Path

class MissingRolePromptError(KeyError):
    pass

def build_min_role_instructions(data_dir: Path) -> None:
    roles_path = data_dir / "roles_cleaned.json"        # has {"roles": [..], ...}
    prompts_path = data_dir / "role_prompts.json"       # {"editor": {...}, ...}
    out_path = data_dir / "roles_instructions.json"

    with open(roles_path, "r", encoding="utf-8") as f:
        roles_doc = json.load(f)
    selected_roles = roles_doc["roles"]

    with open(prompts_path, "r", encoding="utf-8") as f:
        prompts_by_role = json.load(f)

    missing = [r for r in selected_roles if r not in prompts_by_role]
    if missing:
        preview = ", ".join(missing[:20])
        more = "" if len(missing) <= 20 else f" (+{len(missing)-20} more)"
        raise KeyError(f"Missing roles in roles_prompt.json: {preview}{more}")

    # Extract only instruction strings (flatten {"pos": "..."} -> "...")
    roles_out = {}
    for role in selected_roles:
        instr_items = prompts_by_role[role].get("instruction", [])
        instr_strings = []
        for x in instr_items:
            if isinstance(x, dict) and "pos" in x and isinstance(x["pos"], str):
                instr_strings.append(x["pos"].strip())
            elif isinstance(x, str):
                instr_strings.append(x.strip())

        if not instr_strings:
            raise ValueError(f"Role '{role}' has no usable instruction strings")

        roles_out[role] = instr_strings

    out_doc = {
        "description": roles_doc.get("description", "Role instructions"),
        "source": roles_doc.get("source", ""),
        "count": len(selected_roles),
        "roles": roles_out,
    }

    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(out_doc, f, indent=2, ensure_ascii=False)

    print(f"Saved: {out_path}")
    


if __name__ == "__main__":
    # clean_roles()
    # load_roles()
    # load_role_prompts()
    # load_extraction_questions()
    build_min_role_instructions(DATA_DIR)
    
    
    